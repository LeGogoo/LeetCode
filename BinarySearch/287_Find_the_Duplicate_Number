//角度叫钻的二分搜索
//不能更改原数组（假设数组是只读的）。 限制了把数组看成hash表的思路
//只能使用额外的 O(1) 的空间。 限制了最直观的调用set的思路
//时间复杂度小于 O(n2) 。 限制了暴力解法
//数组中只有一个重复的数字，但它可能不止重复出现一次。

//分析：假设数组有n个数字每个数字都在[1,n]范围内且不包含重复
//那么数组为：5，6，1，4，2，7, n, 8.... （n个数字）
//这时小于等于3的有3个 小于等于6的有6个 小于等于n的有n个 1 2 2 3 4 5
//当我们加入一个重复数字后呢
//假设加入2，数组小于等于1的还是1个，但是小于等于2的变成了3个，小于等于5的变成了6个，小于等于n的变成了n+1个
//看看上面的例子，无非就是去找那个第一个使小于等于关系不成立的位置
//当找到1发现还是1，那就在1右边 当找到5变成了6，那就在5的左边，不难发现这里包括5，所以应该说是5及5的左边
//看到上面，自然就是二分搜索了呗，这太明显了，只不过这道题的角度确实和普通的二分搜索不一样，搜的不是一个index而是一个value
//再看一种情况：题目规定了：数组中只有一个重复的数字，但它可能不止重复出现一次.当出现第二个重复数字的话，如果它代替掉左边，没有影响，代替掉右边会+1，对二分搜索也没有影响
//小于等于3 3个
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        size_t numsSize = nums.size();
        int left = 1;
        int right = numsSize - 1;
        int mid;
        while(left < right){
            mid = left + (right - left) / 2;
            int count = 0;
            for(size_t i = 0; i < nums.size(); i++){
                if(nums[i] <= mid)
                    count++;
            }
            if(count <= mid)
                left = mid + 1;
            else//count > mid
                right = mid;
        }//在left == right的时候返回
        return left;
    }
};
//时间复杂度为O(NlongN)
//leetcode耗时16ms beats32.34%的提交记录
//leetcode并不能检查是否违背了题目条件
//看了一下，前面的基本都是错的解
