//链表排序 链表的特点是无法像数组那样通过下标来找值
//如果能开一个链表长度空间的索引表，那么数组能做的链表也都能做
//此题规定只能使用常数空间的复杂度
//故排序的过程中不能使用下标的方式找值（这样会使时间复杂度多O(N)）
//能用的排序手段：冒泡，插入（N^2级） 并归排序的自底向上实现
//但是问题是并归还是会产生O(N)的空间复杂度，用于存并归后的结果
//但是链表恰巧又能把这空间消耗优化掉：
//如： 2->4->6->8->1->3->5->7->NULL 并归：2->4->6->8| |->1->3->5->7->NULL
//并归开始时 left指向2 right指向1 首先找到起始位置 比较*right 和*left 应该为1 把resHead指向1 cur指向1 right=right->next
//比较*right 和*left 2<3 cur->next=left cur=cur->next left=left->next
//比较*right 和*left 3<4 cur->next=right cur=cur->next right=right->next
//.......
//当一个链表结束后 需要注意，如果是左边的提前到头了，那么把cur->next=right就ok了
//但是如果是右边的提前到头了，由于原来最后一个是右边的最后一个，换句话说，右边的最后一个连着下一个开始，那么此时应该cur->next=left的同时
//把左边的最后一个的next连在右边的最后一个的next上
//返回resHead，注意调用函数后，要将原来left前面的个节点的next连在返回的resHead上
//resHead可能是头节点，所以增加一个虚拟头节点，注意最后要delete掉虚拟头节点

//注意实现merge的时候可能有 1 2 3 4 | 3 左右不对等长度的情况
