//此题需要了解一个定理：
//一颗二叉搜索树包括自身所有形态的树的个数，等于左子树的个数乘以右子树的个数
//而此题是一个有序且不包含重复的数组，所以包含同样节点个数的树的形态个数是一样的，例如：123 和 456 都是包含3个节点，树的形态个数都为5
//因为有序且不包含重复，所以3个节点都可以拆分为 1为根 左0右2（4为根 左0右2），2为根左1右1（5为根 左1右1），3为根 左2右0（6为根 左2右0） 
//而左右子树叶是一颗二叉搜索树，故产生了一个递归结构，用动态规划来解
//F(N)为包含N个节点的二叉搜索树的个数
//不难发现对F(N)来说，前N个节点全都可以作为根节点
//F(N)=F(0)*F(N-1)+F(1)*F(N-2)....+F(N-1)*F(0)
class Solution {
public:
    int numTrees(int n) {
        vector<int>memo(n+1,0);
        memo[0]=memo[1]=1;
        //空树和只有一个节点的数都算作是一种可能
        for(int i = 2;i < n + 1;i++)
            for(int j = 0;j < i;j++)
                memo[i]+=memo[j]*memo[i-j-1];
        
        return memo[n];
    }
};
//时间复杂度是O(N^2)
//leetcode用时4ms beats%24.95%的提交记录
