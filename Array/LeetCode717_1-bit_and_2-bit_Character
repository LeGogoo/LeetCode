//本来此题是从后向前思考，能否找到一个最后一个字符是两比特字符的解
//但是实现起来发现会增加成本，比如从后向前如果找到一个01 （正向看是10） 无法确定是该把它连为一个两比特字符 还是分开看
//如果这样实现，就产生了一个递归结构，时间复杂度很可怕，因为2个元素可能是和看，或是分开 时间复杂度为O(2^N)

//仔细观察，此题应该正向思考，因为当出现1时，一定会向后扩展1位，而出现0时便一定时独立的0
//于是只需正向遍历此数组，当结束位置就是最后一个元素时 说明前面一个是独立的0 此时最后一个就是0，一比特字符
//                   当结束位置为最后一个元素后一个时，说明此时最后一个元素被前面的1包含进去了，此时最后一个为两比特字符
class Solution {
public:
    bool isOneBitCharacter(vector<int>& bits) {
        int i;
        int bS=(int)bits.size();
        for(i=0;i<bS-1;){
            if(bits[i]==0)
                i++;
            else if(bits[i]==1)
                i+=2;
        }
        if(i==bS-1)return true;
        else return false;//i==bS
    }
};
//时间复杂度为O(N)
//leetcode 用时4ms beats99.72%的提交记录
